<!DOCTYPE html>
<html>
    <body>
        <script>
            try{
                setTimeout(()=>{throw new Error('Error!');}, 1000);
            }catch(e){
                console.error('캐치한 에러',e);
            }
            /**
             * setTimeout 함수는 1초 후에 콜백 함수가 실행되도록 타이머를 설정하고, 이후 콜백 함수는 에러를 발생시킨다.
             * 하지만 이 에러는 catch코드 블록에서 캐치되지 않는다. 이 이유를 알아보자.
             * 비동기 함수인 setTimeout이 호출되면 setTimeout함수의 실행 컨텍스트가 생성되어 콜 스택에 푸시되어 실행된다.
             * setTimeout은 비동기 함수이므로 콜백 함수가 호출되는 것을 기다리지 않고 즉시 종료되어 콜 스택에서 제거된다.
             * 이후 타이머가 만료되면 setTimeout함수의 콜백 함수는 테스크 큐로 푸시되고 콜 스택이 비어졌을 때 이벤트 루프에 의해
             * 콜 스택으로 푸시되어 실행된다.
             * setTimeout 함수의 콜백 함수가 실행될 때, setTimeout함수는 이미 콜 스택에서 제거된 상태다. 이것은 setTimeout함수의
             * 콜백 함수를 호출한 것이 setTimeout함수가 아니라는 것을 의미한다. setTimeout함수의 콜백 함수의 호출자(caller)가
             * setTimeout함수라면 콜 스택의 현재 실행 중인 실행 컨텍스트가 콜백함수의 실행 컨텍스트일 때 현재 실행 중인 실행 컨텍스트의
             * 하위 실행 컨텍스트가 setTimeout함수여야 한다.
             * 에러는 호출자(caller) 방향으로 전파된다. 
             * 즉, 콜 스택의 아래 방향(실행 중인 실행 컨텍스트가 푸시되기 직전에 푸시된 실행 컨텍스트 방향)으로 전파된다.
             * 하지만 앞에서 살펴본 바와 같이 setTimeout함수의 콜백 함수를 호출한 것은 setTimeout 함수가 아니다. 따라서 setTimeout함수의
             * 콜백 함수가 발생시킨 에러는 catch블록에서 캐치되지 않는다.
             * 
             * 지금까지 살펴본 비동기 처리를 위한 콜백 패턴은 콜백 헬이나 에러 처리가 곤란하다는 문제가 있다. 
             * 이를 극복하기 위해 ES6에서 프로미스가 도입되었다.
             */
        </script>
    </body>
</html>