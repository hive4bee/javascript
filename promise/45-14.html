<!DOCTYPE html>
<html>
    <body>
        <script>
            const promiseGet=url=>{
                return new Promise((resolve,reject)=>{
                    const xhr=new XMLHttpRequest();
                    xhr.open('GET',url);
                    xhr.send();
                    xhr.onload=()=>{
                        if(xhr.status===200){
                            resolve(JSON.parse(xhr.response));
                        }else{
                            reject(new Error(xhr.status));
                        }
                    }
                })
            }
            promiseGet('https://jsonplaceholder.typicode.com/posts/1')
                .then(res => console.log(res))
                .catch(err => console.error(err))
                .finally(()=>console.log('bye'));
            /**
             * then 메서드는 두 개의 콜백 함수를 인수로 전달받는다.
             * 첫 번째 콜백 함수는 프로미스가 fulfilled상태(resolve 함수가 호출된 상태)가 되면 호출된다. 
             * 이때 콜백함수는 프로미스의 비동기 처리 결과를 인수로 전달받는다.
             * 
             * 두 번째 콜백 함수는 프로미스가 rejected상태(reject 함수가 호출된 상태)가 되면 호출된다.
             * 이떄 콜백함수는 프로미스의 에러를 인수로 전달받는다.
             * 
             * then 메서드는 언제나 프로미스를 반환한다. 만약 then메서드의 콜백 함수가 프로미스를 반환하면
             * 그 프로미스를 그대로 반환하고, 콜백함수가 프로미스가 아닌 값을 반환하면 그 값을 암묵적으로 resolve또는 reject하여 프로미스를 생성해 반환한다.
             * 
             * catch메서드는 한 개의 콜백 함수를 인수로 전달받는다. catch메서드의 콜백 함수는 프로미스가 rejected상태인 경우만 호출된다.
             * finally메서드는 한 개의 콜백 함수를 인수로 전달받는다. finally 메서드의 콜백 함수는 프로미스의 성공 또는 실패와 상관없이 무조건 한 번 호출된다.
             */
        </script>
    </body>
</html>